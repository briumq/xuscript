// 订单模块

OrderStatus with [ pending | processing | completed | cancelled | refunded ]
PaymentMethod with [ credit_card | paypal | apple_pay | google_pay | bank_transfer ]

OrderItem has {
    id: string
    order_id: string
    product_id: string
    product_name: string
    quantity: int
    price: float
    total: float
    
    func validate() -> bool {
        return !self.id.none && !self.order_id.none && !self.product_id.none && self.quantity > 0 && self.price > 0.0 && self.total > 0.0
    }
    
    func to_json() -> string {
        return """{
            "id": "{self.id}",
            "order_id": "{self.order_id}",
            "product_id": "{self.product_id}",
            "product_name": "{self.product_name}",
            "quantity": {self.quantity},
            "price": {self.price},
            "total": {self.total}
        }"""
    }
    
    static func create(id: string, order_id: string, product_id: string, product_name: string, quantity: int, price: float) -> OrderItem {
        let total = price * quantity.to_float()
        return OrderItem{
            id: id,
            order_id: order_id,
            product_id: product_id,
            product_name: product_name,
            quantity: quantity,
            price: price,
            total: total
        }
    }
}

Order has {
    id: string
    user_id: string
    items: [OrderItem]
    total: float
    status: OrderStatus = OrderStatus#pending
    payment_method: PaymentMethod
    payment_status: string
    shipping_address: string
    billing_address: string
    tracking_number: string
    created_at: string
    updated_at: string
    
    func validate() -> bool {
        return !self.id.none && !self.user_id.none && self.items.length > 0 && self.total > 0.0
    }
    
    func to_json() -> string {
        let items_json = "["
        for (i, item) in self.items.enumerate() {
            if i > 0 {
                items_json += ","
            }
            items_json += item.to_json()
        }
        items_json += "]"
        
        return """{
            "id": "{self.id}",
            "user_id": "{self.user_id}",
            "items": {items_json},
            "total": {self.total},
            "status": "{self.status}",
            "payment_method": "{self.payment_method}",
            "payment_status": "{self.payment_status}",
            "shipping_address": "{self.shipping_address}",
            "billing_address": "{self.billing_address}",
            "tracking_number": "{self.tracking_number}",
            "created_at": "{self.created_at}",
            "updated_at": "{self.updated_at}"
        }"""
    }
    
    func update_status(new_status: OrderStatus) {
        self.status = new_status
        self.updated_at = "2023-12-01 10:30:00" // 模拟时间
    }
    
    func add_item(item: OrderItem) {
        self.items.push(item)
        self.total += item.total
        self.updated_at = "2023-12-01 10:30:00" // 模拟时间
    }
    
    func remove_item(item_id: string) -> Result[bool, string] {
        let new_items: [OrderItem] = []
        let mut found = false
        let mut removed_total = 0.0
        
        for item in self.items {
            if item.id == item_id {
                found = true
                removed_total = item.total
            } else {
                new_items.push(item)
            }
        }
        
        if found {
            self.items = new_items
            self.total -= removed_total
            self.updated_at = "2023-12-01 10:30:00" // 模拟时间
            return Result#ok(true)
        }
        
        return Result#err("Item not found")
    }
    
    static func create(id: string, user_id: string, items: [OrderItem], payment_method: PaymentMethod, shipping_address: string, billing_address: string) -> Order {
        let now = "2023-12-01 10:30:00" // 模拟时间
        let total = items.reduce(0.0, func(acc, item) -> acc + item.total)
        
        return Order{
            id: id,
            user_id: user_id,
            items: items,
            total: total,
            status: OrderStatus#pending,
            payment_method: payment_method,
            payment_status: "pending",
            shipping_address: shipping_address,
            billing_address: billing_address,
            tracking_number: "",
            created_at: now,
            updated_at: now
        }
    }
}

OrderService has {
    orders: {string: Order}
    product_service: ProductService
    user_service: UserService
    
    func create_order(user_id: string, items: [{string: any}], payment_method: PaymentMethod, shipping_address: string, billing_address: string) -> Result[Order, string] {
        // 验证用户是否存在
        when user = self.user_service.get_user(user_id) {
            // 创建订单项
            let order_items: [OrderItem] = []
            let order_id = "ORD-" + Math.random().to_string()
            
            for (i, item_data) in items.enumerate() {
                when product_id = item_data.get("product_id") {
                    when product = self.product_service.get_product(product_id) {
                        let quantity = item_data.get("quantity").unwrap_or(1)
                        if product.stock < quantity {
                            return Result#err("Insufficient stock for product: {product.name}")
                        }
                        
                        // 更新库存
                        let stock_update = product.update_stock(-quantity)
                        match stock_update {
                            Result#ok(updated_product) {
                                self.product_service.update_product(product_id, {"stock": updated_product.stock})
                            }
                            Result#err(error) {
                                return Result#err(error)
                            }
                            _ {
                                return Result#err("Unknown error updating stock")
                            }
                        }
                        
                        let item_id = "ITEM-" + order_id + "-" + i.to_string()
                        let order_item = OrderItem.create(item_id, order_id, product_id, product.name, quantity, product.price)
                        order_items.push(order_item)
                    } else {
                        return Result#err("Product not found: {product_id}")
                    }
                } else {
                    return Result#err("Missing product_id in item {i}")
                }
            }
            
            if order_items.length == 0 {
                return Result#err("No items in order")
            }
            
            let order = Order.create(order_id, user_id, order_items, payment_method, shipping_address, billing_address)
            if !order.validate() {
                return Result#err("Invalid order")
            }
            
            self.orders[order_id] = order
            return Result#ok(order)
        } else {
            return Result#err("User not found")
        }
    }
    
    func get_order(id: string) -> Option[Order] {
        return self.orders.get(id)
    }
    
    func update_order_status(id: string, status: OrderStatus) -> Result[Order, string] {
        when order = self.orders.get(id) {
            order.update_status(status)
            self.orders[id] = order
            return Result#ok(order)
        } else {
            return Result#err("Order not found")
        }
    }
    
    func update_payment_status(id: string, payment_status: string) -> Result[Order, string] {
        when order = self.orders.get(id) {
            order.payment_status = payment_status
            order.updated_at = "2023-12-01 10:30:00" // 模拟时间
            self.orders[id] = order
            return Result#ok(order)
        } else {
            return Result#err("Order not found")
        }
    }
    
    func update_tracking_number(id: string, tracking_number: string) -> Result[Order, string] {
        when order = self.orders.get(id) {
            order.tracking_number = tracking_number
            order.updated_at = "2023-12-01 10:30:00" // 模拟时间
            self.orders[id] = order
            return Result#ok(order)
        } else {
            return Result#err("Order not found")
        }
    }
    
    func cancel_order(id: string) -> Result[Order, string] {
        when order = self.orders.get(id) {
            if order.status == OrderStatus#completed {
                return Result#err("Cannot cancel completed order")
            }
            
            // 恢复库存
            for item in order.items {
                when product = self.product_service.get_product(item.product_id) {
                    let stock_update = product.update_stock(item.quantity)
                    match stock_update {
                        Result#ok(updated_product) {
                            self.product_service.update_product(item.product_id, {"stock": updated_product.stock})
                        }
                        Result#err(error) {
                            return Result#err(error)
                        }
                        _ {
                            return Result#err("Unknown error updating stock")
                        }
                    }
                }
            }
            
            order.update_status(OrderStatus#cancelled)
            order.payment_status = "cancelled"
            self.orders[id] = order
            return Result#ok(order)
        } else {
            return Result#err("Order not found")
        }
    }
    
    func delete_order(id: string) -> Result[bool, string] {
        if self.orders.contains(id) {
            delete self.orders[id]
            return Result#ok(true)
        }
        return Result#err("Order not found")
    }
    
    func list_orders(user_id: Option[string] = none) -> [Order] {
        let result: [Order] = []
        
        for (_, order) in self.orders {
            if user_id.none || order.user_id == user_id.unwrap() {
                result.push(order)
            }
        }
        
        return result
    }
    
    func list_orders_by_status(status: OrderStatus) -> [Order] {
        let result: [Order] = []
        
        for (_, order) in self.orders {
            if order.status == status {
                result.push(order)
            }
        }
        
        return result
    }
    
    func get_order_statistics() -> {string: any} {
        let total_orders = self.orders.length
        let total_revenue = 0.0
        let status_counts = {}
        
        for (_, order) in self.orders {
            total_revenue += order.total
            
            let status = order.status.to_string()
            if status_counts.contains(status) {
                status_counts[status] = status_counts[status] + 1
            } else {
                status_counts[status] = 1
            }
        }
        
        return {
            "total_orders": total_orders,
            "total_revenue": total_revenue,
            "status_counts": status_counts
        }
    }
    
    static func new(product_service: ProductService, user_service: UserService) -> OrderService {
        return OrderService{
            orders: {},
            product_service: product_service,
            user_service: user_service
        }
    }
}
