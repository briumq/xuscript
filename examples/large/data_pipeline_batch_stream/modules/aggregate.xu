// Data Aggregate Module
// Defines various data aggregators for the pipeline

// Sum aggregator
SumAggregator has {
    field: string

    init(field: string = null) {
        self.field = field
    }

    func apply(data: any) -> any {
        if typeof(data) == "array" {
            if self.field {
                return self._sum_by_field(data)
            } else {
                return self._sum(data)
            }
        } else if typeof(data) == "number" {
            return data
        }
        return data
    }

    func _sum(data: [any]) -> number {
        let sum = 0
        for item in data {
            if typeof(item) == "number" {
                sum += item
            } else if typeof(item) == "object" {
                sum += self._sum_object(item)
            }
        }
        return sum
    }

    func _sum_by_field(data: [any]) -> number {
        let sum = 0
        for item in data {
            if typeof(item) == "object" && item.hasOwnProperty(self.field) {
                if typeof(item[self.field]) == "number" {
                    sum += item[self.field]
                }
            }
        }
        return sum
    }

    func _sum_object(obj: any) -> number {
        let sum = 0
        for key in Object.keys(obj) {
            if typeof(obj[key]) == "number" {
                sum += obj[key]
            } else if typeof(obj[key]) == "array" {
                sum += self._sum(obj[key])
            } else if typeof(obj[key]) == "object" {
                sum += self._sum_object(obj[key])
            }
        }
        return sum
    }

    static func create(field: string = null) -> SumAggregator {
        return SumAggregator{ field: field }
    }
}

// Count aggregator
CountAggregator has {
    field: string

    init(field: string = null) {
        self.field = field
    }

    func apply(data: any) -> any {
        if typeof(data) == "array" {
            if self.field {
                return self._count_by_field(data)
            } else {
                return data.length
            }
        }
        return 1
    }

    func _count_by_field(data: [any]) -> number {
        let count = 0
        for item in data {
            if typeof(item) == "object" && item.hasOwnProperty(self.field) {
                count += 1
            }
        }
        return count
    }

    static func create(field: string = null) -> CountAggregator {
        return CountAggregator{ field: field }
    }
}

// Average aggregator
AverageAggregator has {
    field: string

    init(field: string = null) {
        self.field = field
    }

    func apply(data: any) -> any {
        if typeof(data) == "array" {
            if self.field {
                return self._average_by_field(data)
            } else {
                return self._average(data)
            }
        } else if typeof(data) == "number" {
            return data
        }
        return 0
    }

    func _average(data: [any]) -> number {
        let sum = 0
        let count = 0
        for item in data {
            if typeof(item) == "number" {
                sum += item
                count += 1
            } else if typeof(item) == "object" {
                let obj_sum = 0
                let obj_count = 0
                for key in Object.keys(item) {
                    if typeof(item[key]) == "number" {
                        obj_sum += item[key]
                        obj_count += 1
                    }
                }
                sum += obj_sum
                count += obj_count
            }
        }
        return count > 0 ? sum / count : 0
    }

    func _average_by_field(data: [any]) -> number {
        let sum = 0
        let count = 0
        for item in data {
            if typeof(item) == "object" && item.hasOwnProperty(self.field) {
                if typeof(item[self.field]) == "number" {
                    sum += item[self.field]
                    count += 1
                }
            }
        }
        return count > 0 ? sum / count : 0
    }

    static func create(field: string = null) -> AverageAggregator {
        return AverageAggregator{ field: field }
    }
}

// Min aggregator
MinAggregator has {
    field: string

    init(field: string = null) {
        self.field = field
    }

    func apply(data: any) -> any {
        if typeof(data) == "array" {
            if self.field {
                return self._min_by_field(data)
            } else {
                return self._min(data)
            }
        } else if typeof(data) == "number" {
            return data
        }
        return 0
    }

    func _min(data: [any]) -> number {
        let min = Infinity
        for item in data {
            if typeof(item) == "number" {
                if item < min {
                    min = item
                }
            } else if typeof(item) == "object" {
                let obj_min = self._min_object(item)
                if obj_min < min {
                    min = obj_min
                }
            }
        }
        return min == Infinity ? 0 : min
    }

    func _min_by_field(data: [any]) -> number {
        let min = Infinity
        for item in data {
            if typeof(item) == "object" && item.hasOwnProperty(self.field) {
                if typeof(item[self.field]) == "number" {
                    if item[self.field] < min {
                        min = item[self.field]
                    }
                }
            }
        }
        return min == Infinity ? 0 : min
    }

    func _min_object(obj: any) -> number {
        let min = Infinity
        for key in Object.keys(obj) {
            if typeof(obj[key]) == "number" {
                if obj[key] < min {
                    min = obj[key]
                }
            } else if typeof(obj[key]) == "array" {
                let arr_min = self._min(obj[key])
                if arr_min < min {
                    min = arr_min
                }
            } else if typeof(obj[key]) == "object" {
                let nested_min = self._min_object(obj[key])
                if nested_min < min {
                    min = nested_min
                }
            }
        }
        return min == Infinity ? 0 : min
    }

    static func create(field: string = null) -> MinAggregator {
        return MinAggregator{ field: field }
    }
}

// Max aggregator
MaxAggregator has {
    field: string

    init(field: string = null) {
        self.field = field
    }

    func apply(data: any) -> any {
        if typeof(data) == "array" {
            if self.field {
                return self._max_by_field(data)
            } else {
                return self._max(data)
            }
        } else if typeof(data) == "number" {
            return data
        }
        return 0
    }

    func _max(data: [any]) -> number {
        let max = -Infinity
        for item in data {
            if typeof(item) == "number" {
                if item > max {
                    max = item
                }
            } else if typeof(item) == "object" {
                let obj_max = self._max_object(item)
                if obj_max > max {
                    max = obj_max
                }
            }
        }
        return max == -Infinity ? 0 : max
    }

    func _max_by_field(data: [any]) -> number {
        let max = -Infinity
        for item in data {
            if typeof(item) == "object" && item.hasOwnProperty(self.field) {
                if typeof(item[self.field]) == "number" {
                    if item[self.field] > max {
                        max = item[self.field]
                    }
                }
            }
        }
        return max == -Infinity ? 0 : max
    }

    func _max_object(obj: any) -> number {
        let max = -Infinity
        for key in Object.keys(obj) {
            if typeof(obj[key]) == "number" {
                if obj[key] > max {
                    max = obj[key]
                }
            } else if typeof(obj[key]) == "array" {
                let arr_max = self._max(obj[key])
                if arr_max > max {
                    max = arr_max
                }
            } else if typeof(obj[key]) == "object" {
                let nested_max = self._max_object(obj[key])
                if nested_max > max {
                    max = nested_max
                }
            }
        }
        return max == -Infinity ? 0 : max
    }

    static func create(field: string = null) -> MaxAggregator {
        return MaxAggregator{ field: field }
    }
}

// Median aggregator
MedianAggregator has {
    field: string

    init(field: string = null) {
        self.field = field
    }

    func apply(data: any) -> any {
        if typeof(data) == "array" {
            if self.field {
                return self._median_by_field(data)
            } else {
                return self._median(data)
            }
        } else if typeof(data) == "number" {
            return data
        }
        return 0
    }

    func _median(data: [any]) -> number {
        let numbers = []
        for item in data {
            if typeof(item) == "number" {
                numbers.add(item)
            } else if typeof(item) == "object" {
                numbers = numbers.concat(self._extract_numbers(item))
            }
        }
        return self._calculate_median(numbers)
    }

    func _median_by_field(data: [any]) -> number {
        let numbers = []
        for item in data {
            if typeof(item) == "object" && item.hasOwnProperty(self.field) {
                if typeof(item[self.field]) == "number" {
                    numbers.add(item[self.field])
                }
            }
        }
        return self._calculate_median(numbers)
    }

    func _extract_numbers(obj: any) -> [number] {
        let numbers = []
        for key in Object.keys(obj) {
            if typeof(obj[key]) == "number" {
                numbers.add(obj[key])
            } else if typeof(obj[key]) == "array" {
                for item in obj[key] {
                    if typeof(item) == "number" {
                        numbers.add(item)
                    }
                }
            } else if typeof(obj[key]) == "object" {
                numbers = numbers.concat(self._extract_numbers(obj[key]))
            }
        }
        return numbers
    }

    func _calculate_median(numbers: [number]) -> number {
        if numbers.length == 0 {
            return 0
        }
        numbers.sort((a, b) => a - b)
        let mid = Math.floor(numbers.length / 2)
        if numbers.length % 2 == 0 {
            return (numbers[mid - 1] + numbers[mid]) / 2
        } else {
            return numbers[mid]
        }
    }

    static func create(field: string = null) -> MedianAggregator {
        return MedianAggregator{ field: field }
    }
}

// Mode aggregator
ModeAggregator has {
    field: string

    init(field: string = null) {
        self.field = field
    }

    func apply(data: any) -> any {
        if typeof(data) == "array" {
            if self.field {
                return self._mode_by_field(data)
            } else {
                return self._mode(data)
            }
        } else if typeof(data) == "number" {
            return data
        }
        return 0
    }

    func _mode(data: [any]) -> number {
        let numbers = []
        for item in data {
            if typeof(item) == "number" {
                numbers.add(item)
            } else if typeof(item) == "object" {
                numbers = numbers.concat(self._extract_numbers(item))
            }
        }
        return self._calculate_mode(numbers)
    }

    func _mode_by_field(data: [any]) -> number {
        let numbers = []
        for item in data {
            if typeof(item) == "object" && item.hasOwnProperty(self.field) {
                if typeof(item[self.field]) == "number" {
                    numbers.add(item[self.field])
                }
            }
        }
        return self._calculate_mode(numbers)
    }

    func _extract_numbers(obj: any) -> [number] {
        let numbers = []
        for key in Object.keys(obj) {
            if typeof(obj[key]) == "number" {
                numbers.add(obj[key])
            } else if typeof(obj[key]) == "array" {
                for item in obj[key] {
                    if typeof(item) == "number" {
                        numbers.add(item)
                    }
                }
            } else if typeof(obj[key]) == "object" {
                numbers = numbers.concat(self._extract_numbers(obj[key]))
            }
        }
        return numbers
    }

    func _calculate_mode(numbers: [number]) -> number {
        if numbers.length == 0 {
            return 0
        }
        let counts = {}
        for num in numbers {
            if counts[num] {
                counts[num] += 1
            } else {
                counts[num] = 1
            }
        }
        let max_count = 0
        let mode = numbers[0]
        for num in Object.keys(counts) {
            if counts[num] > max_count {
                max_count = counts[num]
                mode = Number(num)
            }
        }
        return mode
    }

    static func create(field: string = null) -> ModeAggregator {
        return ModeAggregator{ field: field }
    }
}

// Group by aggregator
GroupByAggregator has {
    group_field: string
    aggregations: {string: any}

    init(group_field: string, aggregations: {string: any} = {}) {
        self.group_field = group_field
        self.aggregations = aggregations
    }

    func apply(data: any) -> any {
        if typeof(data) == "array" {
            return self._group_by(data)
        }
        return data
    }

    func _group_by(data: [any]) -> any {
        let groups = {}
        for item in data {
            if typeof(item) == "object" && item.hasOwnProperty(self.group_field) {
                let group_key = item[self.group_field]
                if !groups[group_key] {
                    groups[group_key] = []
                }
                groups[group_key].add(item)
            }
        }
        // Apply aggregations to each group
        let result = {}
        for group_key in Object.keys(groups) {
            result[group_key] = {}
            for agg_key in Object.keys(self.aggregations) {
                let aggregator = self.aggregations[agg_key]
                result[group_key][agg_key] = aggregator.apply(groups[group_key])
            }
        }
        return result
    }

    static func create(group_field: string, aggregations: {string: any} = {}) -> GroupByAggregator {
        return GroupByAggregator{ group_field: group_field, aggregations: aggregations }
    }
}

// Composite aggregator
CompositeAggregator has {
    aggregations: {string: any}

    init(aggregations: {string: any}) {
        self.aggregations = aggregations
    }

    func apply(data: any) -> any {
        let result = {}
        for key in Object.keys(self.aggregations) {
            let aggregator = self.aggregations[key]
            result[key] = aggregator.apply(data)
        }
        return result
    }

    static func create(aggregations: {string: any}) -> CompositeAggregator {
        return CompositeAggregator{ aggregations: aggregations }
    }
}

// Unique aggregator
UniqueAggregator has {
    field: string

    init(field: string = null) {
        self.field = field
    }

    func apply(data: any) -> any {
        if typeof(data) == "array" {
            if self.field {
                return self._unique_by_field(data)
            } else {
                return self._unique(data)
            }
        }
        return [data]
    }

    func _unique(data: [any]) -> [any] {
        let seen = new Set()
        let result = []
        for item in data {
            let stringified = JSON.stringify(item)
            if !seen.has(stringified) {
                seen.add(stringified)
                result.add(item)
            }
        }
        return result
    }

    func _unique_by_field(data: [any]) -> [any] {
        let seen = new Set()
        let result = []
        for item in data {
            if typeof(item) == "object" && item.hasOwnProperty(self.field) {
                let key = item[self.field]
                if !seen.has(key) {
                    seen.add(key)
                    result.add(item)
                }
            }
        }
        return result
    }

    static func create(field: string = null) -> UniqueAggregator {
        return UniqueAggregator{ field: field }
    }
}

// Top N aggregator
TopNAggregator has {
    field: string
    n: int
    sort_order: string

    init(field: string, n: int = 10, sort_order: string = "desc") {
        self.field = field
        self.n = n
        self.sort_order = sort_order
    }

    func apply(data: any) -> any {
        if typeof(data) == "array" {
            return self._top_n(data)
        }
        return data
    }

    func _top_n(data: [any]) -> [any] {
        let sorted = data.sort((a, b) => {
            if typeof(a) == "object" && a.hasOwnProperty(self.field) && typeof(b) == "object" && b.hasOwnProperty(self.field) {
                if self.sort_order == "desc" {
                    return b[self.field] - a[self.field]
                } else {
                    return a[self.field] - b[self.field]
                }
            }
            return 0
        })
        return sorted.slice(0, self.n)
    }

    static func create(field: string, n: int = 10, sort_order: string = "desc") -> TopNAggregator {
        return TopNAggregator{ field: field, n: n, sort_order: sort_order }
    }
}

// Bottom N aggregator
BottomNAggregator has {
    field: string
    n: int

    init(field: string, n: int = 10) {
        self.field = field
        self.n = n
    }

    func apply(data: any) -> any {
        if typeof(data) == "array" {
            return self._bottom_n(data)
        }
        return data
    }

    func _bottom_n(data: [any]) -> [any] {
        let sorted = data.sort((a, b) => {
            if typeof(a) == "object" && a.hasOwnProperty(self.field) && typeof(b) == "object" && b.hasOwnProperty(self.field) {
                return a[self.field] - b[self.field]
            }
            return 0
        })
        return sorted.slice(0, self.n)
    }

    static func create(field: string, n: int = 10) -> BottomNAggregator {
        return BottomNAggregator{ field: field, n: n }
    }
}

// Statistics aggregator
StatisticsAggregator has {
    field: string

    init(field: string = null) {
        self.field = field
    }

    func apply(data: any) -> any {
        if typeof(data) == "array" {
            let sum_agg = SumAggregator.create(self.field)
            let count_agg = CountAggregator.create(self.field)
            let min_agg = MinAggregator.create(self.field)
            let max_agg = MaxAggregator.create(self.field)
            let avg_agg = AverageAggregator.create(self.field)
            let median_agg = MedianAggregator.create(self.field)
            let mode_agg = ModeAggregator.create(self.field)

            return {
                sum: sum_agg.apply(data),
                count: count_agg.apply(data),
                min: min_agg.apply(data),
                max: max_agg.apply(data),
                average: avg_agg.apply(data),
                median: median_agg.apply(data),
                mode: mode_agg.apply(data)
            }
        }
        return data
    }

    static func create(field: string = null) -> StatisticsAggregator {
        return StatisticsAggregator{ field: field }
    }
}
