// Data Sink Module
// Defines various data sinks for the pipeline

// Base sink interface
interface DataSink {
    write(data: any) -> bool
    flush() -> bool
    close()
}

// File data sink
class FileDataSink implements DataSink {
    file_path: string
    mode: string
    delimiter: string
    headers: [string]
    written_count: int

    init(file_path: string, mode: string = "w", delimiter: string = ",", headers: [string] = []) {
        self.file_path = file_path
        self.mode = mode
        self.delimiter = delimiter
        self.headers = headers
        self.written_count = 0
    }

    write(data: any) -> bool {
        if typeof(data) == "array" {
            for item in data {
                self._write_item(item)
            }
        } else {
            self._write_item(data)
        }
        return true
    }

    _write_item(item: any) {
        if typeof(item) == "array" {
            let line = item.join(self.delimiter)
            self._write_line(line)
        } else if typeof(item) == "object" {
            let values = []
            if self.headers.length > 0 {
                for header in self.headers {
                    values.push(item[header] || "")
                }
            } else {
                for key in Object.keys(item) {
                    values.push(item[key])
                }
            }
            let line = values.join(self.delimiter)
            self._write_line(line)
        } else {
            self._write_line(String(item))
        }
        self.written_count += 1
    }

    _write_line(line: string) {
        // Simulate writing to file
        println("FileSink[{self.file_path}]: {line}")
    }

    flush() -> bool {
        println("FileSink[{self.file_path}]: Flushed {self.written_count} records")
        return true
    }

    close() {
        println("FileSink[{self.file_path}]: Closed, total written: {self.written_count}")
    }
}

// Database data sink
class DatabaseDataSink implements DataSink {
    connection_string: string
    table_name: string
    batch_size: int
    current_batch: [any]
    written_count: int

    init(connection_string: string, table_name: string = "data", batch_size: int = 100) {
        self.connection_string = connection_string
        self.table_name = table_name
        self.batch_size = batch_size
        self.current_batch = []
        self.written_count = 0
    }

    write(data: any) -> bool {
        if typeof(data) == "array" {
            for item in data {
                self.current_batch.push(item)
                if self.current_batch.length >= self.batch_size {
                    self._flush_batch()
                }
            }
        } else {
            self.current_batch.push(data)
            if self.current_batch.length >= self.batch_size {
                self._flush_batch()
            }
        }
        return true
    }

    _flush_batch() {
        if self.current_batch.length > 0 {
            println("DatabaseSink[{self.table_name}]: Writing batch of {self.current_batch.length} records")
            self.written_count += self.current_batch.length
            self.current_batch = []
        }
    }

    flush() -> bool {
        self._flush_batch()
        println("DatabaseSink[{self.table_name}]: Flushed, total written: {self.written_count}")
        return true
    }

    close() {
        self.flush()
        println("DatabaseSink[{self.table_name}]: Closed, total written: {self.written_count}")
    }
}

// Kafka data sink
class KafkaDataSink implements DataSink {
    bootstrap_servers: string
    topic: string
    key_field: string
    written_count: int

    init(bootstrap_servers: string, topic: string, key_field: string = null) {
        self.bootstrap_servers = bootstrap_servers
        self.topic = topic
        self.key_field = key_field
        self.written_count = 0
    }

    write(data: any) -> bool {
        if typeof(data) == "array" {
            for item in data {
                self._write_message(item)
            }
        } else {
            self._write_message(data)
        }
        return true
    }

    _write_message(message: any) {
        let key = null
        if self.key_field && typeof(message) == "object" && message.hasOwnProperty(self.key_field) {
            key = message[self.key_field]
        }
        println("KafkaSink[{self.topic}]: Sending message - Key: {key}, Value: {message}")
        self.written_count += 1
    }

    flush() -> bool {
        println("KafkaSink[{self.topic}]: Flushed, total written: {self.written_count}")
        return true
    }

    close() {
        println("KafkaSink[{self.topic}]: Closed, total written: {self.written_count}")
    }
}

// HTTP data sink
class HttpDataSink implements DataSink {
    url: string
    method: string
    headers: {string: string}
    written_count: int

    init(url: string, method: string = "POST", headers: {string: string} = {}) {
        self.url = url
        self.method = method
        self.headers = headers
        self.written_count = 0
    }

    write(data: any) -> bool {
        if typeof(data) == "array" {
            for item in data {
                self._send_request(item)
            }
        } else {
            self._send_request(data)
        }
        return true
    }

    _send_request(data: any) {
        println("HttpSink[{self.url}]: Sending {self.method} request with data: {data}")
        self.written_count += 1
    }

    flush() -> bool {
        println("HttpSink[{self.url}]: Flushed, total written: {self.written_count}")
        return true
    }

    close() {
        println("HttpSink[{self.url}]: Closed, total written: {self.written_count}")
    }
}

// In-memory data sink
class InMemoryDataSink implements DataSink {
    data: [any]
    capacity: int

    init(capacity: int = 10000) {
        self.data = []
        self.capacity = capacity
    }

    write(data: any) -> bool {
        if typeof(data) == "array" {
            for item in data {
                if self.data.length < self.capacity {
                    self.data.push(item)
                } else {
                    println("InMemorySink: Capacity reached, discarding data")
                }
            }
        } else {
            if self.data.length < self.capacity {
                self.data.push(data)
            } else {
                println("InMemorySink: Capacity reached, discarding data")
            }
        }
        return true
    }

    flush() -> bool {
        println("InMemorySink: Flushed, current size: {self.data.length}")
        return true
    }

    close() {
        println("InMemorySink: Closed, total stored: {self.data.length}")
    }

    get_data() -> [any] {
        return self.data
    }
}

// Console data sink
class ConsoleDataSink implements DataSink {
    format: string
    written_count: int

    init(format: string = "json") {
        self.format = format
        self.written_count = 0
    }

    write(data: any) -> bool {
        if typeof(data) == "array" {
            for item in data {
                self._print_item(item)
            }
        } else {
            self._print_item(data)
        }
        return true
    }

    _print_item(item: any) {
        if self.format == "json" {
            println(JSON.stringify(item))
        } else if self.format == "pretty" {
            println("=== Item {self.written_count + 1} ===")
            self._print_pretty(item)
            println("================")
        } else {
            println(item)
        }
        self.written_count += 1
    }

    _print_pretty(item: any, indent: int = 0) {
        if typeof(item) == "object" {
            for key in Object.keys(item) {
                let value = item[key]
                let padding = "  ".repeat(indent)
                if typeof(value) == "object" {
                    println("{padding}{key}:")
                    self._print_pretty(value, indent + 1)
                } else {
                    println("{padding}{key}: {value}")
                }
            }
        } else if typeof(item) == "array" {
            for i in 0..item.length-1 {
                let value = item[i]
                let padding = "  ".repeat(indent)
                println("{padding}[{i}]:")
                self._print_pretty(value, indent + 1)
            }
        } else {
            println("  ".repeat(indent) + item)
        }
    }

    flush() -> bool {
        println("ConsoleSink: Flushed, total written: {self.written_count}")
        return true
    }

    close() {
        println("ConsoleSink: Closed, total written: {self.written_count}")
    }
}

// Composite data sink
class CompositeDataSink implements DataSink {
    sinks: [DataSink]

    init(sinks: [DataSink] = []) {
        self.sinks = sinks
    }

    add_sink(sink: DataSink) {
        self.sinks.push(sink)
    }

    write(data: any) -> bool {
        let success = true
        for sink in self.sinks {
            if !sink.write(data) {
                success = false
            }
        }
        return success
    }

    flush() -> bool {
        let success = true
        for sink in self.sinks {
            if !sink.flush() {
                success = false
            }
        }
        return success
    }

    close() {
        for sink in self.sinks {
            sink.close()
        }
    }
}

// Null data sink (discards data)
class NullDataSink implements DataSink {
    written_count: int

    init() {
        self.written_count = 0
    }

    write(data: any) -> bool {
        if typeof(data) == "array" {
            self.written_count += data.length
        } else {
            self.written_count += 1
        }
        return true
    }

    flush() -> bool {
        return true
    }

    close() {
        println("NullDataSink: Closed, total discarded: {self.written_count}")
    }
}

// Retry data sink wrapper
class RetryDataSink implements DataSink {
    sink: DataSink
    max_retries: int
    retry_delay_ms: int

    init(sink: DataSink, max_retries: int = 3, retry_delay_ms: int = 1000) {
        self.sink = sink
        self.max_retries = max_retries
        self.retry_delay_ms = retry_delay_ms
    }

    write(data: any) -> bool {
        let retries = 0
        while retries <= self.max_retries {
            try {
                if self.sink.write(data) {
                    return true
                }
            } catch (e) {
                println("RetryDataSink: Error writing data: {e}")
            }
            retries += 1
            if retries <= self.max_retries {
                println("RetryDataSink: Retrying in {self.retry_delay_ms}ms...")
                // Simulate delay
            }
        }
        return false
    }

    flush() -> bool {
        let retries = 0
        while retries <= self.max_retries {
            try {
                if self.sink.flush() {
                    return true
                }
            } catch (e) {
                println("RetryDataSink: Error flushing data: {e}")
            }
            retries += 1
            if retries <= self.max_retries {
                println("RetryDataSink: Retrying in {self.retry_delay_ms}ms...")
                // Simulate delay
            }
        }
        return false
    }

    close() {
        self.sink.close()
    }
}

// Compression data sink wrapper
class CompressionDataSink implements DataSink {
    sink: DataSink
    compression_type: string

    init(sink: DataSink, compression_type: string = "gzip") {
        self.sink = sink
        self.compression_type = compression_type
    }

    write(data: any) -> bool {
        let compressed = self._compress(data)
        return self.sink.write(compressed)
    }

    _compress(data: any) -> any {
        // Simulate compression
        if typeof(data) == "string" {
            return "[COMPRESSED({self.compression_type})]" + data
        } else if typeof(data) == "object" {
            return { "compressed": true, "type": self.compression_type, "data": data }
        }
        return data
    }

    flush() -> bool {
        return self.sink.flush()
    }

    close() {
        self.sink.close()
    }
}

// Encryption data sink wrapper
class EncryptionDataSink implements DataSink {
    sink: DataSink
    encryption_key: string

    init(sink: DataSink, encryption_key: string = "default-key") {
        self.sink = sink
        self.encryption_key = encryption_key
    }

    write(data: any) -> bool {
        let encrypted = self._encrypt(data)
        return self.sink.write(encrypted)
    }

    _encrypt(data: any) -> any {
        // Simulate encryption
        if typeof(data) == "string" {
            return "[ENCRYPTED]" + data
        } else if typeof(data) == "object" {
            return { "encrypted": true, "data": data }
        }
        return data
    }

    flush() -> bool {
        return self.sink.flush()
    }

    close() {
        self.sink.close()
    }
}
