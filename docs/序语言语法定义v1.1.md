# Xu 语言语义定义 v1.1

---

## 1. 概述

本文档定义 Xu 语言的形式语义，作为规范文档的补充。采用操作语义风格描述。

### 1.1 符号约定

|符号|含义|
|---|---|
|`Γ`|环境（变量名 → 值的映射）|
|`Σ`|类型环境（变量名 → 类型的映射）|
|`e ⇓ v`|表达式 e 求值为值 v|
|`s ⇒ Γ'`|语句 s 执行后产生新环境 Γ'|
|`Γ ⊢ e : T`|在环境 Γ 下，表达式 e 具有类型 T|
|`⊥`|程序终止（panic）|

---

## 2. 值域定义

### 2.1 基本值

text

```
Value ::= IntVal(n)           n ∈ ℤ
        | FloatVal(f)         f ∈ ℝ
        | StringVal(s)        s ∈ String
        | BoolVal(b)          b ∈ {true, false}
        | ListVal([v₁...vₙ])
        | DictVal({k₁:v₁...})
        | SetVal({v₁...vₙ})
        | TupleVal((v₁...vₙ))
        | StructVal(T, {f₁:v₁...})
        | EnumVal(T, variant, {f₁:v₁...})
        | FuncVal(params, body, Γ_closure)
        | OptionVal(some(v) | none)
        | ResultVal(ok(v) | err(e))
```

### 2.2 类型

text

```
Type ::= int | float | string | bool
       | [T]                    // 列表
       | {K: V}                 // 字典
       | {T}                    // 集合
       | (T₁, T₂, ..., Tₙ)      // 元组
       | T..T                   // 范围（仅 int）
       | StructType(name, fields)
       | EnumType(name, variants)
       | Option[T]
       | Result[T, E]
       | Func([T₁...Tₙ] -> R)
```

---

## 3. 环境与作用域

### 3.1 环境结构

text

```
Γ = { name₁ ↦ (value₁, mutable₁), 
      name₂ ↦ (value₂, mutable₂), 
      ... }

其中 mutable ∈ {true, false}
```

### 3.2 作用域规则

**作用域层级**：

text

```
Global → Module → Function → Block
```

**变量查找**（由内向外）：

text

```
lookup(Γ, x) = 
    if x ∈ current_scope(Γ) then current_scope(Γ)[x]
    else lookup(parent(Γ), x)
```

**禁止遮蔽约束**：

text

```
declare(Γ, x, v, m) = 
    if exists_in_chain(Γ, x) then ERROR("shadowing not allowed")
    else Γ ∪ {x ↦ (v, m)}
```

---

## 4. 表达式求值

### 4.1 字面量

text

```
─────────────────
Γ ⊢ n ⇓ IntVal(n)

─────────────────────
Γ ⊢ f ⇓ FloatVal(f)

───────────────────────
Γ ⊢ "s" ⇓ StringVal(s)

─────────────────────
Γ ⊢ true ⇓ BoolVal(true)

──────────────────────
Γ ⊢ false ⇓ BoolVal(false)
```

### 4.2 变量引用

text

```
x ↦ (v, _) ∈ Γ
──────────────
Γ ⊢ x ⇓ v

x ∉ Γ
─────────────────────────
Γ ⊢ x ⇓ ERROR("undefined")
```

### 4.3 算术运算

text

```
Γ ⊢ e₁ ⇓ IntVal(n₁)    Γ ⊢ e₂ ⇓ IntVal(n₂)
───────────────────────────────────────────
Γ ⊢ e₁ + e₂ ⇓ IntVal(n₁ + n₂)

Γ ⊢ e₁ ⇓ IntVal(n₁)    Γ ⊢ e₂ ⇓ IntVal(0)
──────────────────────────────────────────
Γ ⊢ e₁ / e₂ ⇓ ⊥  // panic: division by zero
```

### 4.4 比较运算

text

```
Γ ⊢ e₁ ⇓ v₁    Γ ⊢ e₂ ⇓ v₂    equal(v₁, v₂) = b
────────────────────────────────────────────────
Γ ⊢ e₁ is e₂ ⇓ BoolVal(b)

Γ ⊢ e₁ ⇓ v₁    Γ ⊢ e₂ ⇓ v₂    equal(v₁, v₂) = b
────────────────────────────────────────────────
Γ ⊢ e₁ isnt e₂ ⇓ BoolVal(¬b)
```

### 4.5 逻辑运算（短路求值）

text

```
Γ ⊢ e₁ ⇓ BoolVal(false)
───────────────────────
Γ ⊢ e₁ and e₂ ⇓ BoolVal(false)

Γ ⊢ e₁ ⇓ BoolVal(true)    Γ ⊢ e₂ ⇓ BoolVal(b)
──────────────────────────────────────────────
Γ ⊢ e₁ and e₂ ⇓ BoolVal(b)

Γ ⊢ e₁ ⇓ BoolVal(true)
──────────────────────
Γ ⊢ e₁ or e₂ ⇓ BoolVal(true)

Γ ⊢ e₁ ⇓ BoolVal(false)    Γ ⊢ e₂ ⇓ BoolVal(b)
──────────────────────────────────────────────
Γ ⊢ e₁ or e₂ ⇓ BoolVal(b)

Γ ⊢ e ⇓ BoolVal(b)
──────────────────
Γ ⊢ not e ⇓ BoolVal(¬b)
```

### 4.6 字符串插值

text

```
Γ ⊢ e₁ ⇓ v₁  ...  Γ ⊢ eₙ ⇓ vₙ
─────────────────────────────────────────────────
Γ ⊢ "...{e₁}...{eₙ}..." ⇓ StringVal(concat(format(v₁)...format(vₙ)))
```

### 4.7 集合字面量

**列表**：

text

```
Γ ⊢ e₁ ⇓ v₁  ...  Γ ⊢ eₙ ⇓ vₙ
─────────────────────────────
Γ ⊢ [e₁, ..., eₙ] ⇓ ListVal([v₁...vₙ])
```

**字典**：

text

```
Γ ⊢ k₁ ⇓ kv₁  Γ ⊢ v₁ ⇓ vv₁  ...
────────────────────────────────
Γ ⊢ {k₁: v₁, ...} ⇓ DictVal({kv₁:vv₁...})
```

**范围**：

text

```
Γ ⊢ e₁ ⇓ IntVal(n₁)    Γ ⊢ e₂ ⇓ IntVal(n₂)
──────────────────────────────────────────
Γ ⊢ e₁..e₂ ⇓ RangeVal(n₁, n₂, exclusive)

Γ ⊢ e₁ ⇓ IntVal(n₁)    Γ ⊢ e₂ ⇓ IntVal(n₂)
──────────────────────────────────────────
Γ ⊢ e₁..=e₂ ⇓ RangeVal(n₁, n₂, inclusive)
```

### 4.8 if 表达式

text

```
Γ ⊢ cond ⇓ BoolVal(true)    Γ ⊢ e₁ ⇓ v
────────────────────────────────────────
Γ ⊢ if cond { e₁ } else { e₂ } ⇓ v

Γ ⊢ cond ⇓ BoolVal(false)    Γ ⊢ e₂ ⇓ v
────────────────────────────────────────
Γ ⊢ if cond { e₁ } else { e₂ } ⇓ v
```

### 4.9 match 表达式

text

```
Γ ⊢ e ⇓ v    pattern_match(v, pᵢ) = Some(bindings)    Γ ∪ bindings ⊢ bodyᵢ ⇓ result
──────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ match e { p₁ { body₁ } ... pₙ { bodyₙ } _ { default_body } } ⇓ result
```

> 语法约束：`match` 必须包含一个最终 `_ { ... }` 默认分支。`p: stmt` 视为 `{ stmt }` 的语法糖。

### 4.10 函数调用

text

```
Γ ⊢ f ⇓ FuncVal(params, body, Γ_closure)
Γ ⊢ arg₁ ⇓ v₁  ...  Γ ⊢ argₙ ⇓ vₙ
Γ_call = Γ_closure ∪ {param₁ ↦ (v₁, false), ..., paramₙ ↦ (vₙ, false)}
Γ_call ⊢ body ⇓ result
────────────────────────────────────────────
Γ ⊢ f(arg₁, ..., argₙ) ⇓ result
```

### 4.11 属性访问

text

```
Γ ⊢ e ⇓ StructVal(T, fields)    f ↦ v ∈ fields
──────────────────────────────────────────────
Γ ⊢ e.f ⇓ v
```

### 4.12 索引访问（强访问）

text

```
Γ ⊢ e ⇓ ListVal(vs)    Γ ⊢ idx ⇓ IntVal(i)    0 ≤ i < len(vs)
─────────────────────────────────────────────────────────────
Γ ⊢ e[idx] ⇓ vs[i]

Γ ⊢ e ⇓ ListVal(vs)    Γ ⊢ idx ⇓ IntVal(i)    i < 0 ∨ i ≥ len(vs)
─────────────────────────────────────────────────────────────────
Γ ⊢ e[idx] ⇓ ⊥  // panic: index out of bounds

Γ ⊢ e ⇓ DictVal(kvs)    Γ ⊢ k ⇓ kv    kv ↦ v ∈ kvs
──────────────────────────────────────────────────
Γ ⊢ e[k] ⇓ v

Γ ⊢ e ⇓ DictVal(kvs)    Γ ⊢ k ⇓ kv    kv ∉ keys(kvs)
────────────────────────────────────────────────────
Γ ⊢ e[k] ⇓ ⊥  // panic: key not found
```

### 4.13 枚举构造

text

```
T = EnumType(name, variants)    variant ∈ variants
Γ ⊢ arg₁ ⇓ v₁  ...
─────────────────────────────────────────────────
Γ ⊢ T#variant(arg₁, ...) ⇓ EnumVal(T, variant, {f₁:v₁...})

T = EnumType(name, variants)    variant ∈ variants    variant.fields = ∅
────────────────────────────────────────────────────────────────────────
Γ ⊢ T#variant ⇓ EnumVal(T, variant, {})
```

### 4.14 匿名函数

text

```
────────────────────────────────────────────────────────────
Γ ⊢ func(params) -> expr ⇓ FuncVal(params, Return(expr), Γ)

────────────────────────────────────────────────────────────
Γ ⊢ func(params) -> T { body } ⇓ FuncVal(params, body, Γ)
```

---

## 5. 语句执行

### 5.1 变量声明

**let（不可变绑定）**：

text

```
Γ ⊢ e ⇓ v    x ∉ scope_chain(Γ)
───────────────────────────────
Γ ⊢ let x = e ⇒ Γ ∪ {x ↦ (v, false)}

x ∈ scope_chain(Γ)
──────────────────────────────────────
Γ ⊢ let x = e ⇒ ERROR("shadowing x")
```

**var（可变绑定）**：

text

```
Γ ⊢ e ⇓ v    x ∉ scope_chain(Γ)
───────────────────────────────
Γ ⊢ var x = e ⇒ Γ ∪ {x ↦ (v, true)}
```

### 5.2 赋值

text

```
x ↦ (_, true) ∈ Γ    Γ ⊢ e ⇓ v
──────────────────────────────
Γ ⊢ x = e ⇒ Γ[x ↦ (v, true)]

x ↦ (_, false) ∈ Γ
──────────────────────────────────────────
Γ ⊢ x = e ⇒ ERROR("cannot assign to immutable")

x ∉ Γ
────────────────────────────────
Γ ⊢ x = e ⇒ ERROR("undefined x")
```

**复合赋值**：

text

```
Γ ⊢ x ⇓ v₁    Γ ⊢ e ⇓ v₂    x ↦ (_, true) ∈ Γ
──────────────────────────────────────────────
Γ ⊢ x += e ⇒ Γ[x ↦ (v₁ + v₂, true)]
```

### 5.3 if 语句

text

```
Γ ⊢ cond ⇓ BoolVal(true)    Γ ⊢ body ⇒ Γ'
─────────────────────────────────────────
Γ ⊢ if cond { body } ⇒ Γ

Γ ⊢ cond ⇓ BoolVal(false)
─────────────────────────
Γ ⊢ if cond { body } ⇒ Γ

Γ ⊢ cond ⇓ BoolVal(false)    Γ ⊢ else_body ⇒ Γ'
────────────────────────────────────────────────
Γ ⊢ if cond { body } else { else_body } ⇒ Γ
```

> 注：块内变量不泄漏到外层环境。
>
> 语法糖：`if cond: stmt` 视为 `if cond { stmt }`；`if cond:\n  stmt` 同理（缩进仅排版，无语义）。

### 5.4 while 循环

text

```
Γ ⊢ cond ⇓ BoolVal(false)
─────────────────────────
Γ ⊢ while cond { body } ⇒ Γ

Γ ⊢ cond ⇓ BoolVal(true)    Γ ⊢ body ⇒ Γ₁    Γ₁ ⊢ while cond { body } ⇒ Γ₂
────────────────────────────────────────────────────────────────────────────
Γ ⊢ while cond { body } ⇒ Γ₂
```

> 语法糖：`while cond: stmt` 视为 `while cond { stmt }`。

### 5.5 for 循环

text

```
Γ ⊢ iter ⇓ IterableVal(vs)    vs = []
─────────────────────────────────────
Γ ⊢ for x in iter { body } ⇒ Γ

Γ ⊢ iter ⇓ IterableVal([v₁, v₂, ...vₙ])
Γ₀ = Γ
for i = 1 to n:
    Γᵢ₋₁ ∪ {x ↦ (vᵢ, false)} ⊢ body ⇒ Γᵢ'
────────────────────────────────────────────
Γ ⊢ for x in iter { body } ⇒ Γ
```

> 语法糖：`for x in iter: stmt` 视为 `for x in iter { stmt }`。

### 5.6 break 和 continue

text

```
───────────────────────────────
Γ ⊢ break ⇒ BREAK

───────────────────────────────
Γ ⊢ continue ⇒ CONTINUE
```

> BREAK 和 CONTINUE 是特殊控制信号，由包围的循环捕获处理。

### 5.7 return

text

```
Γ ⊢ e ⇓ v
──────────────────
Γ ⊢ return e ⇒ RETURN(v)

──────────────────
Γ ⊢ return ⇒ RETURN(unit)
```

### 5.8 match 语句

text

```
Γ ⊢ e ⇓ v    pattern_match(v, pᵢ) = Some(bindings)    Γ ∪ bindings ⊢ bodyᵢ ⇒ Γ'
───────────────────────────────────────────────────────────────────────────────
Γ ⊢ match e { p₁ { body₁ } ... _ { default_body } } ⇒ Γ
```

> 语法约束：`match` 必须包含一个最终 `_ { ... }` 默认分支。`p: stmt` 视为 `{ stmt }` 的语法糖。

### 5.9 when 语句

**单绑定**：

text

```
Γ ⊢ e ⇓ OptionVal(some(v))    Γ ∪ {x ↦ (v, false)} ⊢ body ⇒ Γ'
──────────────────────────────────────────────────────────────
Γ ⊢ when x = e { body } else { else_body } ⇒ Γ

Γ ⊢ e ⇓ OptionVal(none)    Γ ⊢ else_body ⇒ Γ'
──────────────────────────────────────────────
Γ ⊢ when x = e { body } else { else_body } ⇒ Γ
```

**多绑定短路**：

text

```
Γ ⊢ e₁ ⇓ OptionVal(some(v₁))  ...  Γ ⊢ eₙ ⇓ OptionVal(some(vₙ))
Γ ∪ {x₁ ↦ (v₁, false), ..., xₙ ↦ (vₙ, false)} ⊢ body ⇒ Γ'
────────────────────────────────────────────────────────────────
Γ ⊢ when x₁ = e₁, ..., xₙ = eₙ { body } else { else_body } ⇒ Γ

∃i. Γ ⊢ eᵢ ⇓ OptionVal(none)    Γ ⊢ else_body ⇒ Γ'
──────────────────────────────────────────────────
Γ ⊢ when x₁ = e₁, ..., xₙ = eₙ { body } else { else_body } ⇒ Γ
```

**Result 绑定**：

text

```
Γ ⊢ e ⇓ ResultVal(ok(v))    Γ ∪ {x ↦ (v, false)} ⊢ body ⇒ Γ'
─────────────────────────────────────────────────────────────
Γ ⊢ when x = e { body } else { else_body } ⇒ Γ

Γ ⊢ e ⇓ ResultVal(err(_))    Γ ⊢ else_body ⇒ Γ'
───────────────────────────────────────────────
Γ ⊢ when x = e { body } else { else_body } ⇒ Γ
```

---

## 6. 模式匹配

### 6.1 模式语法

text

```
Pattern ::= _                           // 通配符
          | literal                     // 字面量
          | name                        // 绑定变量
          | Type#variant                // 枚举（无数据）
          | Type#variant(p₁, ..., pₙ)   // 枚举（有数据）
          | (p₁, ..., pₙ)               // 元组
```

### 6.2 匹配规则

text

```
pattern_match(v, _) = Some({})

pattern_match(IntVal(n), n) = Some({})
pattern_match(IntVal(n), m) = None    where n ≠ m

pattern_match(v, name) = Some({name ↦ v})

pattern_match(EnumVal(T, var, _), T#var) = Some({})

pattern_match(EnumVal(T, var, {f₁:v₁...}), T#var(p₁...)) = 
    combine(pattern_match(v₁, p₁), ...)

pattern_match(TupleVal((v₁...vₙ)), (p₁...pₙ)) = 
    combine(pattern_match(v₁, p₁), ..., pattern_match(vₙ, pₙ))
```

### 6.3 穷尽性检查

text

```
exhaustive(patterns, EnumType(variants)) = 
    ∀v ∈ variants. ∃p ∈ patterns. covers(p, v)
    ∨ ∃p ∈ patterns. p = _
```

---

## 7. 类型规则

### 7.1 字面量类型

text

```
─────────────────
Σ ⊢ n : int

─────────────────
Σ ⊢ f : float

─────────────────
Σ ⊢ "s" : string

─────────────────
Σ ⊢ true : bool
Σ ⊢ false : bool
```

### 7.2 变量类型

text

```
x : T ∈ Σ
─────────
Σ ⊢ x : T
```

### 7.3 算术运算类型

text

```
Σ ⊢ e₁ : int    Σ ⊢ e₂ : int
────────────────────────────
Σ ⊢ e₁ + e₂ : int

Σ ⊢ e₁ : float    Σ ⊢ e₂ : float
────────────────────────────────
Σ ⊢ e₁ + e₂ : float

Σ ⊢ e₁ : string    Σ ⊢ e₂ : string
──────────────────────────────────
Σ ⊢ e₁ + e₂ : string
```

### 7.4 比较运算类型

text

```
Σ ⊢ e₁ : T    Σ ⊢ e₂ : T    T ∈ {int, float, string, bool}
──────────────────────────────────────────────────────────
Σ ⊢ e₁ is e₂ : bool
Σ ⊢ e₁ isnt e₂ : bool
```

### 7.5 集合类型

text

```
Σ ⊢ e₁ : T  ...  Σ ⊢ eₙ : T
───────────────────────────
Σ ⊢ [e₁, ..., eₙ] : [T]

Σ ⊢ k₁ : K  Σ ⊢ v₁ : V  ...
───────────────────────────
Σ ⊢ {k₁: v₁, ...} : {K: V}

Σ ⊢ e₁ : T  ...  Σ ⊢ eₙ : T
───────────────────────────
Σ ⊢ set{e₁, ..., eₙ} : {T}

Σ ⊢ e₁ : T₁  ...  Σ ⊢ eₙ : Tₙ
─────────────────────────────
Σ ⊢ (e₁, ..., eₙ) : (T₁, ..., Tₙ)
```

### 7.6 范围类型

text

```
Σ ⊢ e₁ : int    Σ ⊢ e₂ : int
────────────────────────────
Σ ⊢ e₁..e₂ : Range[int]
Σ ⊢ e₁..=e₂ : Range[int]
```

### 7.7 函数类型

text

```
Σ ∪ {p₁: T₁, ..., pₙ: Tₙ} ⊢ body : R
────────────────────────────────────────────────
Σ ⊢ func(p₁: T₁, ..., pₙ: Tₙ) -> R { body } : Func([T₁...Tₙ] -> R)
```

### 7.8 if 表达式类型

text

```
Σ ⊢ cond : bool    Σ ⊢ e₁ : T    Σ ⊢ e₂ : T
───────────────────────────────────────────
Σ ⊢ if cond { e₁ } else { e₂ } : T
```

### 7.9 match 表达式类型

text

```
Σ ⊢ e : T_match
∀i. Σ ∪ bindings(pᵢ) ⊢ bodyᵢ : T_result
exhaustive([p₁...pₙ], T_match)
───────────────────────────────────────────
Σ ⊢ match e { p₁ { body₁ } ... pₙ { bodyₙ } } : T_result
```

### 7.10 Option/Result 类型

text

```
Σ ⊢ e : T
─────────────────────────────
Σ ⊢ Option#some(e) : Option[T]

─────────────────────────────
Σ ⊢ Option#none : Option[T]

Σ ⊢ e : T
─────────────────────────────
Σ ⊢ Result#ok(e) : Result[T, E]

Σ ⊢ e : E
─────────────────────────────
Σ ⊢ Result#err(e) : Result[T, E]
```

---

## 8. 结构体语义

### 8.1 定义

text

```
define_struct(name, fields, methods) = 
    StructType(name, {
        fields: [(f₁, T₁, default₁), ...],
        methods: [(m₁, Func), ...],
        static_methods: [(s₁, Func), ...]
    })
```

### 8.2 实例化

text

```
T = StructType(name, {fields: [(f₁, T₁, d₁), ...]})
∀fᵢ. (fᵢ: vᵢ) ∈ provided ∨ dᵢ ≠ ∅
Γ ⊢ vᵢ : Tᵢ
──────────────────────────────────────────────────
Γ ⊢ T{ f₁: v₁, ... } ⇓ StructVal(T, {f₁:v₁, ...})
```

### 8.3 展开运算

text

```
Γ ⊢ e ⇓ StructVal(T, fields_src)
fields_new = fields_src ∪ overrides    // overrides 覆盖同名字段
───────────────────────────────────────────────────────────────
Γ ⊢ T{ ...e, f₁: v₁, ... } ⇓ StructVal(T, fields_new)
```

### 8.4 方法调用

text

```
Γ ⊢ e ⇓ StructVal(T, fields)
m ↦ FuncVal(params, body, _) ∈ methods(T)
Γ' = {self ↦ (StructVal(T, fields), false)} ∪ {p₁ ↦ (v₁, false), ...}
Γ' ⊢ body ⇓ result
────────────────────────────────────────────────────────────────────
Γ ⊢ e.m(v₁, ...) ⇓ result
```

### 8.5 静态方法

text

```
T = StructType(name, ...)
s ↦ FuncVal(params, body, _) ∈ static_methods(T)
Γ' = {p₁ ↦ (v₁, false), ...}
Γ' ⊢ body ⇓ result
────────────────────────────────────────────────
Γ ⊢ T.s(v₁, ...) ⇓ result
```

---

## 9. 枚举语义

### 9.1 定义

text

```
define_enum(name, variants) = 
    EnumType(name, [
        (variant₁, [(f₁, T₁), ...]),
        (variant₂, []),
        ...
    ])
```

### 9.2 构造

text

```
T = EnumType(name, variants)
(var, fields) ∈ variants
∀(fᵢ, Tᵢ) ∈ fields. Γ ⊢ vᵢ : Tᵢ
────────────────────────────────────────────────
Γ ⊢ T#var(v₁, ...) ⇓ EnumVal(T, var, {f₁:v₁...})
```

---

## 10. does 扩展语义

### 10.1 规则

text

```
T = StructType(name, ...) ∨ T = EnumType(name, ...)
T defined in current_module
methods = [(m₁, Func₁), ...]
─────────────────────────────────────────────────────────
T does { methods } ⇒ extend_methods(T, methods)
```

### 10.2 约束

text

```
// 禁止扩展内置类型
T ∈ {int, float, string, bool, [_], {_:_}, {_}}
──────────────────────────────────────────────
T does { ... } ⇒ ERROR("cannot extend builtin type")

// 禁止跨模块扩展
T defined in other_module
───────────────────────────
T does { ... } ⇒ ERROR("cannot extend type from other module")
```

---

## 11. 模块语义

### 11.1 模块加载

text

```
load_module(path) = 
    if cached(path) then get_cache(path)
    else
        source = read_file(path)
        ast = parse(source)
        exports = evaluate_top_level(ast)
        set_cache(path, exports)
        exports
```

### 11.2 use 语句

text

```
exports = load_module(path)
─────────────────────────────────────
Γ ⊢ use "path" ⇒ Γ

exports = load_module(path)
─────────────────────────────────────────
Γ ⊢ use "path" as alias ⇒ Γ ∪ {alias ↦ exports}
```

> 语义约束：`use "path"` 仅触发模块加载/执行与缓存，不会把导出成员注入当前作用域；访问导出通过 `alias.member`，其中 `alias` 可以由路径默认推断或用 `as` 显式指定。

### 11.3 可见性

text

```
// 默认公开
define(x, v) ⇒ export(x, v)

// inner 标记为私有
inner define(x, v) ⇒ local_only(x, v)
```

---

## 12. Option/Result 组合子语义

### 12.1 Option 组合子

text

```
// .has
OptionVal(some(_)).has ⇓ BoolVal(true)
OptionVal(none).has ⇓ BoolVal(false)

// .none
OptionVal(some(_)).none ⇓ BoolVal(false)
OptionVal(none).none ⇓ BoolVal(true)

// .or(default)
OptionVal(some(v)).or(_) ⇓ v
OptionVal(none).or(d) ⇓ d

// .or_else(func)
OptionVal(some(v)).or_else(_) ⇓ v
OptionVal(none).or_else(f) ⇓ f()

// .map(func)
OptionVal(some(v)).map(f) ⇓ OptionVal(some(f(v)))
OptionVal(none).map(_) ⇓ OptionVal(none)

// .then(func)
OptionVal(some(v)).then(f) ⇓ f(v)    // f 返回 Option
OptionVal(none).then(_) ⇓ OptionVal(none)

// .each(func)
OptionVal(some(v)).each(f) ⇓ f(v); unit
OptionVal(none).each(_) ⇓ unit

// .filter(pred)
OptionVal(some(v)).filter(p) ⇓ if p(v) { OptionVal(some(v)) } else { OptionVal(none) }
OptionVal(none).filter(_) ⇓ OptionVal(none)
```

### 12.2 Result 组合子

text

```
// .or(default)
ResultVal(ok(v)).or(_) ⇓ v
ResultVal(err(_)).or(d) ⇓ d

// .map(func)
ResultVal(ok(v)).map(f) ⇓ ResultVal(ok(f(v)))
ResultVal(err(e)).map(_) ⇓ ResultVal(err(e))

// .map_err(func)
ResultVal(ok(v)).map_err(_) ⇓ ResultVal(ok(v))
ResultVal(err(e)).map_err(f) ⇓ ResultVal(err(f(e)))

// .then(func)
ResultVal(ok(v)).then(f) ⇓ f(v)    // f 返回 Result
ResultVal(err(e)).then(_) ⇓ ResultVal(err(e))
```

---

## 13. 容器操作语义

### 13.1 列表

text

```
// 安全访问
ListVal(vs).first ⇓ if len(vs) > 0 { OptionVal(some(vs[0])) } else { OptionVal(none) }
ListVal(vs).get(i) ⇓ if 0 ≤ i < len(vs) { OptionVal(some(vs[i])) } else { OptionVal(none) }

// 强访问
ListVal(vs)[i] ⇓ if 0 ≤ i < len(vs) { vs[i] } else { ⊥ }

// 属性
ListVal(vs).length ⇓ IntVal(len(vs))
ListVal(vs).any ⇓ BoolVal(len(vs) > 0)

// 修改（原地）
ListVal(vs).add(v) ⇓ append(vs, v); unit
```

### 13.2 字典

text

```
// 安全访问
DictVal(kvs).get(k) ⇓ if k ∈ keys(kvs) { OptionVal(some(kvs[k])) } else { OptionVal(none) }

// 强访问
DictVal(kvs)[k] ⇓ if k ∈ keys(kvs) { kvs[k] } else { ⊥ }
```

---

## 14. Panic 语义

text

```
// panic 终止当前执行
⊥ 传播直到顶层，终止脚本

// 产生 panic 的情况
- 除以零
- 索引越界（强访问）
- 键不存在（强访问）
- 模式匹配不穷尽（运行时未匹配）
```

---

## 附录：求值顺序

### A.1 表达式求值顺序

- 从左到右求值
- 短路求值：`and` / `or`
- 函数参数：从左到右

### A.2 语句执行顺序

- 顺序执行
- 控制流按语义规则跳转
- BREAK / CONTINUE / RETURN 立即中断当前块
