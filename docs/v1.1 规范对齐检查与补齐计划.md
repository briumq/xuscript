## 对齐目标（按你已拍板的口径）
- 无 `null`：用户态不允许 `null` 关键字/字面量；不确定性统一用 Option/Result。
- 默认严格：未声明变量赋值必须编译错误；`let` 不可重新赋值。
- `when` 的 `else` 分支可省略（省略时 none/err 情况不执行任何操作）。
- `use` 对齐规范：彻底替换现有 `import`（关键字与语法糖），模块导入只保留 `use ... (as ...)`。
- 清理 `try/catch/finally/throw`：从关键字与语法入口移除，相关测试/用例同步清理。

## 现状差异清单（需要落地的改动项）
1. 关键字集合与词法：规范 28 关键字 vs 现有实现的关键字/特殊处理不一致。
2. `null` 暴露：lexer/parser/runtime/tests 均存在用户态 `null`。
3. strict 默认行为：实现存在 strict/non-strict 分支，规范要求默认严格。
4. 容器安全访问：规范要求 `list.first` / `map.get(k)` 返回 Option；当前 list/dict 没有该行为。
5. `use` 语义：当前把 `use/import` 都降级为 `import(...)` 调用；需要改为真正的 `use` 导入语义（并移除 import）。
6. 结构体字段默认值：规范支持 `field: Ty = expr`；当前解析/IR/初始化链路缺失。
7. 空容器类型标注：规范要求空容器显式标注（例如 `let xs: [int] = []` / `let m: {string: int} = {}` / `let s: {int} = set{}`）；当前实现允许不标注。
8. 列表类型标注语法：规范 `[T]` 当前不支持（类型解析不接受 `[` 起始）。

## 实施步骤（确认后开始改代码与回归）
### 1) 词法/语法入口“按规范收敛”
- lexer：
  - 移除 `null/try/catch/finally/throw/import` 作为关键字。
  - 把规范 28 关键字全部纳入关键字 token（含 `let/var/does/inner/static/self/in/use/as/has/with` 等），避免靠 Ident 文本特判。
- parser：
  - 移除 `try/throw` 语句解析入口；移除 `import(...)` 语法糖入口。
  - 实现规范 `use "path"` / `use "path" as alias` 的语句 AST（不再降级为函数调用）。
  - 实现类型标注 `[T]`（映射到内部 list 类型）。

### 2) 模块系统：让 `use` 成为唯一导入机制
- 在 IR/Runtime 中引入（或补齐）“导入语句”的一等表示与执行：
  - 执行模块顶层一次并缓存（符合规范）。
  - `as` 别名绑定到模块对象。
  - 同步修复：现有测试/stdlib/示例里所有 `import` 相关写法全部替换为 `use`。

### 3) 去 `null`：把“空值”从用户态抹除
- 语法层：删除 `null` 字面量与相关 token。
- 语义层：梳理所有“返回空值”的内置/方法（如 list.add/dict.insert/merge 等）
  - 统一改为返回可表达的“单位值”（建议采用 `()` 作为单位值输出形式；内部可继续复用现有空值表示但不再称为 null、也不可写入）。
- 测试层：
  - 替换所有依赖 `null` 的用例（例如 `Option.each(...) is null` 改为断言单位值或改写为不接收返回值）。

### 4) 默认严格：未声明赋值一律错误
- 将 CLI 的 check/run 默认 strict 打开；runner 与 CLI 口径一致。
- 更新/新增 tests/specs：覆盖“未声明赋值报错”“let 重新赋值报错”“shadowing 规则”等。

### 5) 容器访问对齐 v1.1
- 实现 `list.first -> Option[T]`：空列表返回 `Option#none`，否则 `Option#some(first)`。
- 实现 `map.get(key) -> Option[V]`：缺失返回 `Option#none`，存在返回 `Option#some(v)`。
- 更新现有 `v1_1_container_access`/相关用例，补齐 v1.1 第 11 章的正向/负向覆盖。

### 6) 结构体字段默认值（全链路）
- parser：支持 `field: Ty = expr`。
- IR：StructField 扩展保存 default expr。
- runtime：结构体字面量缺省字段时自动填默认值；同时类型检查保证 default 表达式类型匹配。
- tests/specs：按规范完整示例补齐（含默认枚举变体值）。

### 7) 空容器类型标注强制
- 在检查阶段对 `[] / {} / set{}` 的空字面量缺失类型注解报错。
- 更新现有用例，给空容器补类型标注，确保与规范一致。

### 8) 回归与基线
- 全量 `cargo test`。
- 如涉及 golden 输出更新，统一刷新并确保 CI 通过。
- 最终产出：
  - “v1.1 对齐完成清单”（哪些条目已对齐、哪些明确不做/延后）。
  - 更新后的 `tests/v1_1_drafts/问题列表.md` 仅保留真正未实现/待决项。

## 风险点与控制
- 关键字收敛会影响“把 let/var/inner 等当作标识符”的旧代码；这是符合规范的破坏性变更，会通过全量 tests/specs 兜底。
- `use` 替换 `import` 涉及大量测试/示例/stdlib 的批量迁移；优先用全局检索替换+逐个修复编译错误。

如果这个方案 OK，我会在退出计划模式后按上述顺序开始改代码，并保证全量回归通过。