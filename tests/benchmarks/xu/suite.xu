// Unified benchmark suite (English version)
var BENCH_SMOKE = "0"
var BENCH_SCALE = "10000"

Foo has {
  x: int

  func method(n: int) -> int {
    return self.x + n
  }
}

func run(name: string, repeat: int, logic) -> float {
  var min = 999999999999.0
  for _ in [1..repeat] {
    var start = mono_micros()
    logic()
    var end = mono_micros()
    var cost = (end - start) * 1.0
    if cost < min {
      min = cost
    }
  }
  return min / 1000.0
}

func bench_loop(N: int) -> float {
  func logic() {
    var c = 0
    for _ in [1..N] {
      c += 1
    }
  }
  return run("loop_" + to_text(N), 7, logic)
}

func bench_dict(N: int) -> float {
  func logic() {
    let d = {}
    for i in [0..N-1] {
      let k = "k" + to_text(i)
      d.insert(k, i)
    }
    var sum = 0
    for i in [0..N-1] {
      let k = "k" + to_text(i)
      sum += d.get(k)
    }
  }
  return run("dict_" + to_text(N), 7, logic)
}

func bench_dict_hot(N: int) -> float {
  func logic() {
    let d = {}
    for i in [0..N-1] {
      d.insert(to_text(i), i)
    }
    for _ in [0..N-1] {
      let _v = d.get("0")
    }
  }
  return run("dict_hot_" + to_text(N), 7, logic)
}

func bench_dict_intkey(N: int) -> float {
  func logic() {
    let d = {}
    for i in [0..N-1] {
      d.insert_int(i, i)
    }
    var sum = 0
    for i in [0..N-1] {
      sum += d.get_int(i)
    }
  }
  return run("dict_intkey_" + to_text(N), 7, logic)
}

func bench_string(N: int) -> float {
  func logic() {
    var s = ""
    for i in [0..N-1] {
      s += i
      s += ","
    }
  }
  return run("string_" + to_text(N), 7, logic)
}

func bench_string_builder(N: int) -> float {
  func logic() {
    let b = builder_new()
    for i in [0..N-1] {
      builder_push(b, i)
      builder_push(b, ",")
    }
    let s = builder_finalize(b)
  }
  return run("string_builder_" + to_text(N), 7, logic)
}

func bench_struct_method(N: int) -> float {
  func logic() {
    let f = Foo{ x: 1 }
    for i in [0..N-1] {
      let _v = f.method(i)
    }
  }
  return run("struct_method_" + to_text(N), 7, logic)
}

func bench_func_call(N: int) -> float {
  func add1(x: int) -> int { return x + 1 }
  func logic() {
    var s = 0
    for i in [0..N-1] {
      s += add1(i)
    }
  }
  return run("func_call_" + to_text(N), 7, logic)
}

func bench_branch_heavy(N: int) -> float {
  func logic() {
    var s = 0
    for i in [0..N-1] {
      if (i % 2) is 0 { s += 1 } else { s -= 1 }
    }
  }
  return run("branch_heavy_" + to_text(N), 7, logic)
}

func bench_list_push_pop(N: int) -> float {
  func logic() {
    let l = []
    for i in [0..N-1] { l.add(i) }
    for i in [0..N-1] { let _ = l.pop() }
  }
  return run("list_push_pop_" + to_text(N), 7, logic)
}

func bench_dict_miss(N: int) -> float {
  func logic() {
    let d = {}
    for i in [0..N-1] { d.insert("k" + to_text(i), i) }
    var s = 0
    for i in [0..N-1] {
      let miss = d.contains("x" + to_text(i))
      if miss { s += 1 }
    }
  }
  return run("dict_miss_" + to_text(N), 7, logic)
}

func bench_dict_update_hot(N: int) -> float {
  func logic() {
    let d = {}
    d.insert("hot", 0)
    for i in [0..N-1] { d.insert("hot", i) }
  }
  return run("dict_update_hot_" + to_text(N), 7, logic)
}

func bench_string_unicode(N: int) -> float {
  func logic() {
    let parts = ["ã“ã‚“ã«ã¡ã¯", "ä¸–ç•ŒðŸŒ", "Xu", "è„šæœ¬"]
    let b = builder_new()
    for i in [0..N-1] {
      builder_push(b, parts[i % 4])
      builder_push(b, ",")
    }
    let _s = builder_finalize(b)
  }
  return run("string_unicode_" + to_text(N), 7, logic)
}

func bench_string_scan(N: int) -> float {
  func logic() {
    var s = ""
    for i in [0..N-1] {
      s += i
      s += ","
    }
    let _c1 = contains(s, "999")
    let _c2 = starts_with(s, "0,1")
    let _c3 = ends_with(s, to_text(N - 1))
  }
  return run("string_scan_" + to_text(N), 7, logic)
}
func bench_try_catch(N: int) -> float {
  func logic() {
    var placeholder = 0
    for i in [1..N] {
      try {
        throw "e"
      } catch error {
        if error.length() > 0 {
          placeholder = 0
        }
      } finally {
        placeholder = 0
      }
    }
  }
  return run("try_catch_" + to_text(N), 7, logic)
}

func ä¸»ç¨‹åº() {
  var sizes = [5000, 10000]
  if BENCH_SMOKE == "1" {
    sizes = [500]
  }

  var parsed = 0
  try {
    parsed = parse_int(BENCH_SCALE)
  } catch _ {
    parsed = 0
  }
  if parsed > 0 {
    sizes = [parsed]
  }
  
  for N in sizes {
    var v = bench_loop(N)
    print("{\"case\":\"loop\",\"scale\":" + to_text(N) + ",\"duration_ms\":" + to_text(v) + "}")
    
    v = bench_dict(N)
    print("{\"case\":\"dict\",\"scale\":" + to_text(N) + ",\"duration_ms\":" + to_text(v) + "}")
    
    v = bench_dict_hot(N)
    print("{\"case\":\"dict-hot\",\"scale\":" + to_text(N) + ",\"duration_ms\":" + to_text(v) + "}")
    
    v = bench_dict_intkey(N)
    print("{\"case\":\"dict-intkey\",\"scale\":" + to_text(N) + ",\"duration_ms\":" + to_text(v) + "}")
    
    v = bench_string(N)
    print("{\"case\":\"string\",\"scale\":" + to_text(N) + ",\"duration_ms\":" + to_text(v) + "}")
    
    v = bench_string_builder(N)
    print("{\"case\":\"string-builder\",\"scale\":" + to_text(N) + ",\"duration_ms\":" + to_text(v) + "}")
    
    v = bench_struct_method(N)
    print("{\"case\":\"struct-method\",\"scale\":" + to_text(N) + ",\"duration_ms\":" + to_text(v) + "}")
    
    v = bench_try_catch(N)
    print("{\"case\":\"try-catch\",\"scale\":" + to_text(N) + ",\"duration_ms\":" + to_text(v) + "}")

    v = bench_func_call(N)
    print("{\"case\":\"func-call\",\"scale\":" + to_text(N) + ",\"duration_ms\":" + to_text(v) + "}")

    v = bench_branch_heavy(N)
    print("{\"case\":\"branch-heavy\",\"scale\":" + to_text(N) + ",\"duration_ms\":" + to_text(v) + "}")

    v = bench_list_push_pop(N)
    print("{\"case\":\"list-push-pop\",\"scale\":" + to_text(N) + ",\"duration_ms\":" + to_text(v) + "}")

    v = bench_dict_miss(N)
    print("{\"case\":\"dict-miss\",\"scale\":" + to_text(N) + ",\"duration_ms\":" + to_text(v) + "}")

    v = bench_dict_update_hot(N)
    print("{\"case\":\"dict-update-hot\",\"scale\":" + to_text(N) + ",\"duration_ms\":" + to_text(v) + "}")

    v = bench_string_unicode(N)
    print("{\"case\":\"string-unicode\",\"scale\":" + to_text(N) + ",\"duration_ms\":" + to_text(v) + "}")

    v = bench_string_scan(N)
    print("{\"case\":\"string-scan\",\"scale\":" + to_text(N) + ",\"duration_ms\":" + to_text(v) + "}")
  }
}
