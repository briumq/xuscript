// Xu full benchmark suite with JSON output (matching Python/Node.js style)
// BENCH_SCALE can be set via environment variable, defaults to "5000"
func get_bench_scale() -> string {
  let env_val = env_get("BENCH_SCALE")
  if env_val != "" { return env_val }
  return "5000"
}
var BENCH_SCALE = get_bench_scale()

Foo has {
  x: int
  func method(n: int) -> int { return self.x + n }
}

func now_us() -> int { return mono_micros() }

func out_json(name: string, N: int, ms: float) {
  let b = builder_new()
  builder_push(b, "\{")
  builder_push(b, "\"case\":\"")
  builder_push(b, name)
  builder_push(b, "\",\"scale\":")
  builder_push(b, N)
  builder_push(b, ",\"duration_ms\":")
  builder_push(b, ms)
  builder_push(b, ",\"rss_bytes\":")
  builder_push(b, process_rss())
  builder_push(b, "\}")
  let result = builder_finalize(b)
  print(result)
}

func bench_loop(N: int) -> float {
  let t0 = now_us()
  var s = 0
  for _ in [0..N-1] { s += 1 }
  let t1 = now_us()
  return (t1 - t0) / 1000.0
}

func bench_dict(N: int) -> float {
  let t0 = now_us()
  let d: {string: int} = {}
  for i in [0..N-1] { d.insert("k" + to_text(i), i) }
  var s = 0
  for i in [0..N-1] { s += d["k" + to_text(i)] }
  let t1 = now_us()
  return (t1 - t0) / 1000.0
}

func bench_dict_intkey(N: int) -> float {
  let t0 = now_us()
  let d: {int: int} = {}
  for i in [0..N-1] { d.insert(i, i) }
  var s = 0
  for i in [0..N-1] { s += d[i] }
  let t1 = now_us()
  return (t1 - t0) / 1000.0
}

func bench_dict_hot(N: int) -> float {
  let d: {string: int} = {}
  for i in [0..N-1] { d.insert("k" + to_text(i), i) }
  let hot = "k" + to_text(N / 2)
  let t0 = now_us()
  var s = 0
  for _ in [0..N-1] { s += d[hot] }
  let t1 = now_us()
  return (t1 - t0) / 1000.0
}

func bench_string(N: int) -> float {
  let t0 = now_us()
  // Match Python: arr = [str(i) for i in range(n)]; s = ",".join(arr); parts = s.split(",")
  let arr: [int] = []
  for i in [0..N-1] { arr.push(i) }
  let s = arr.join(",")
  let _parts = s.split(",")
  let t1 = now_us()
  return (t1 - t0) / 1000.0
}

func bench_string_builder(N: int) -> float {
  let t0 = now_us()
  // Match Python: parts = []; for i in range(n): parts.append(str(i)); s = ",".join(parts)
  let parts: [int] = []
  for i in [0..N-1] { parts.push(i) }
  let _s = parts.join(",")
  let t1 = now_us()
  return (t1 - t0) / 1000.0
}

func bench_struct_method(N: int) -> float {
  let o = Foo{ x: 1 }
  let t0 = now_us()
  var s = 0
  for i in [0..N-1] { s += o.method(i) }
  let t1 = now_us()
  return (t1 - t0) / 1000.0
}

func bench_func_call(N: int) -> float {
  func f(x: int) -> int { return x + 1 }
  let t0 = now_us()
  var s = 0
  for i in [0..N-1] { s += f(i) }
  let t1 = now_us()
  return (t1 - t0) / 1000.0
}

func bench_branch_heavy(N: int) -> float {
  let t0 = now_us()
  var s = 0
  for i in [0..N-1] {
    if (i % 2) == 0 { s += 1 }
    else { s -= 1 }
  }
  let t1 = now_us()
  return (t1 - t0) / 1000.0
}

func bench_list_push_pop(N: int) -> float {
  let t0 = now_us()
  let l: [int] = []
  for i in [0..N-1] { l.push(i) }
  for _ in [0..N-1] { let _ = l.pop() }
  let t1 = now_us()
  return (t1 - t0) / 1000.0
}

func bench_dict_miss(N: int) -> float {
  let d: {string: int} = {}
  for i in [0..N-1] { d.insert("k" + to_text(i), i) }
  let t0 = now_us()
  var s = 0
  for i in [0..N-1] { s += if d.contains("x" + to_text(i)) { 1 } else { 0 } }
  let t1 = now_us()
  return (t1 - t0) / 1000.0
}

func bench_dict_update_hot(N: int) -> float {
  let d: {string: int} = {}
  d["hot"] = 0
  let t0 = now_us()
  for i in [0..N-1] { d["hot"] = i }
  let t1 = now_us()
  return (t1 - t0) / 1000.0
}

func bench_string_unicode(N: int) -> float {
  let t0 = now_us()
  // Match Python: parts = ["ã“ã‚“ã«ã¡ã¯", "ä¸–ç•ŒðŸŒ", "Xu", "è„šæœ¬"] * (n // 4); s = ",".join(parts); out = s.split(",")
  let base = ["ã“ã‚“ã«ã¡ã¯", "ä¸–ç•ŒðŸŒ", "Xu", "è„šæœ¬"]
  let parts = base.repeat(N / 4)
  let s = parts.join(",")
  let _out = s.split(",")
  let t1 = now_us()
  return (t1 - t0) / 1000.0
}

func bench_string_scan(N: int) -> float {
  // Build string outside of timing (like Python/Node.js)
  // Match Python: s = ",".join([str(i) for i in range(n)])
  let arr: [int] = []
  for i in [0..N-1] { arr.push(i) }
  let s = arr.join(",")
  let t0 = now_us()
  let _c1 = contains(s, "999")
  let _c2 = starts_with(s, "0,1")
  let _c3 = ends_with(s, to_text(N - 1))
  let t1 = now_us()
  return (t1 - t0) / 1000.0
}

func bench_closure_create(N: int) -> float {
  // Create N closures that capture a variable
  let t0 = now_us()
  var sum = 0
  for i in [0..N-1] {
    let captured = i
    let f = |x: int| x + captured
    sum += f(1)
  }
  let t1 = now_us()
  return (t1 - t0) / 1000.0
}

func bench_closure_call(N: int) -> float {
  // Create one closure and call it N times
  let captured = 42
  let f = |x: int| x + captured
  let t0 = now_us()
  var sum = 0
  for i in [0..N-1] { sum += f(i) }
  let t1 = now_us()
  return (t1 - t0) / 1000.0
}

func main() {
  var N = parse_int(BENCH_SCALE)
  out_json("loop", N, bench_loop(N))
  out_json("dict", N, bench_dict(N))
  out_json("dict-intkey", N, bench_dict_intkey(N))
  out_json("dict-hot", N, bench_dict_hot(N))
  out_json("string", N, bench_string(N))
  out_json("string-builder", N, bench_string_builder(N))
  out_json("struct-method", N, bench_struct_method(N))
  out_json("func-call", N, bench_func_call(N))
  out_json("branch-heavy", N, bench_branch_heavy(N))
  out_json("list-push-pop", N, bench_list_push_pop(N))
  out_json("dict-miss", N, bench_dict_miss(N))
  out_json("dict-update-hot", N, bench_dict_update_hot(N))
  out_json("string-unicode", N, bench_string_unicode(N))
  out_json("string-scan", N, bench_string_scan(N))
  out_json("closure-create", N, bench_closure_create(N))
  out_json("closure-call", N, bench_closure_call(N))
}

main()
