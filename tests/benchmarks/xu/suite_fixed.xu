// Unified benchmark suite (English version)
use "std/json"

var BENCH_SMOKE = "0";
var BENCH_SCALE = "5000";

Foo has { x: int }
func (self: Foo) add(n: int) -> int {
  return self.x + n
}

func run(name: string, repeat: int, logic) -> int {
  var min = 999999999999.0
  for _ in [1..repeat] {
    var start = mono_micros()
    logic()
    var end = mono_micros()
    var cost = end - start
    if cost < min {
      min = cost
    }
  }
  return parse_int((min + 500.0) / 1000.0)
}

func bench_loop(N: int) -> int {
  func logic() {
    var c = 0
    for _ in [1..N] {
      c += 1
    }
  }
  return run("loop_" + to_text(N), 7, logic)
}

func bench_dict(N: int) -> int {
  func logic() {
    let d = {}
    for i in [0..N-1] {
      let k = "k" + to_text(i)
      d insert(k, i)
    }
    var sum = 0
    for i in [0..N-1] {
      let k = "k" + to_text(i)
      sum += d get(k)
    }
  }
  return run("dict_" + to_text(N), 7, logic)
}

func bench_dict_hot(N: int) -> int {
  func logic() {
    let d = {}
    for i in [0..N-1] {
      d insert(to_text(i), i)
    }
    for _ in [0..N-1] {
      let _v = d get("0")
    }
  }
  return run("dict_hot_" + to_text(N), 7, logic)
}

func bench_dict_intkey(N: int) -> int {
  func logic() {
    let d = {}
    for i in [0..N-1] {
      d insert_int(i, i)
    }
    var sum = 0
    for i in [0..N-1] {
      sum += d get_int(i)
    }
  }
  return run("dict_intkey_" + to_text(N), 7, logic)
}

func bench_string(N: int) -> int {
  func logic() {
    var s = ""
    for i in [0..N-1] {
      s += i
      s += ","
    }
  }
  return run("string_" + to_text(N), 7, logic)
}

func bench_string_builder(N: int) -> int {
  func logic() {
    let b = builder_new()
    for i in [0..N-1] {
      builder_push(b, i)
      builder_push(b, ",")
    }
    let s = builder_finalize(b)
  }
  return run("string_builder_" + to_text(N), 7, logic)
}

func bench_struct_method(N: int) -> int {
  func logic() {
    let f = Foo{ x: 1 }
    for i in [0..N-1] {
      let _v = f add(i)
    }
  }
  return run("struct_method_" + to_text(N), 7, logic)
}

func bench_try_catch(N: int) -> int {
  func logic() {
    for _ in [1..N] {
      try {
        throw "e"
      } catch error {
        if error.length() > 0 {
          let _ = 0
        }
      } finally {
        let _ = 0
      }
    }
  }
  return run("try_catch_" + to_text(N), 7, logic)
}

func make_json(N: int) -> string {
  let b = builder_new()
  builder_push(b, "\{")
  for i in [0..N-1] {
    builder_push(b, "\"k")
    builder_push(b, i)
    builder_push(b, "\":")
    builder_push(b, i)
    if i < N-1 {
      builder_push(b, ",")
    }
  }
  builder_push(b, "\}")
  return builder_finalize(b)
}

func bench_json(N: int) -> int {
  let s = make_json(N)
  func logic() {
    let _R = json_parse(s)
  }
  return run("json_" + to_text(N), 5, logic)
}

func main() {
  let Sizes = [5000, 10000]
  
  try {
    if BENCH_SMOKE == "1" {
      let Sizes = [500]
    }
  } catch _ {
    let _ = 0
  }

  try {
    if parse_int(BENCH_SCALE) > 0 {
      let Sizes = [parse_int(BENCH_SCALE)]
    }
  } catch _ {
    let _ = 0
  }
  
  for N in Sizes {
    let v = bench_loop(N)
    print("loop_" + to_text(N) + "=" + to_text(v))
    
    v = bench_dict(N)
    print("dict_" + to_text(N) + "=" + to_text(v))
    
    v = bench_dict_hot(N)
    print("dict_hot_" + to_text(N) + "=" + to_text(v))
    
    v = bench_dict_intkey(N)
    print("dict_intkey_" + to_text(N) + "=" + to_text(v))
    
    v = bench_string(N)
    print("string_" + to_text(N) + "=" + to_text(v))
    
    v = bench_string_builder(N)
    print("string_builder_" + to_text(N) + "=" + to_text(v))
    
    v = bench_struct_method(N)
    print("struct_method_" + to_text(N) + "=" + to_text(v))
    
    v = bench_try_catch(N)
    print("try_catch_" + to_text(N) + "=" + to_text(v))
    
    // v = bench_json(N)
    // print("json_" + to_text(N) + "=" + to_text(v))
  }
}

main()
