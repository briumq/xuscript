// Xu full benchmark suite with JSON output (safe subset)
// BENCH_SCALE can be set via environment variable, defaults to "5000"
func get_bench_scale() -> string {
  let env_val = env_get("BENCH_SCALE")
  if env_val != "" { return env_val }
  return "5000"
}
var BENCH_SCALE = get_bench_scale()

Foo has {
  x: int
  func method(n: int) -> int { return self.x + n }
}

func now_us() -> int { return mono_micros() }

func run_avg_ms(repeat: int, logic) -> float {
  var total = 0.0
  for _ in [1..repeat] {
    var s = now_us()
    logic()
    var e = now_us()
    gc()
    total += (e - s)
  }
  return total / repeat / 1000.0
}

func out_json(name: string, N: int, ms: float) {
  let b = builder_new()
  builder_push(b, "\{")
  builder_push(b, "\"case\":\"")
  builder_push(b, name)
  builder_push(b, "\",\"scale\":")
  builder_push(b, N)
  builder_push(b, ",\"duration_ms\":")
  builder_push(b, ms)
  builder_push(b, ",\"rss_bytes\":")
  builder_push(b, process_rss())
  builder_push(b, "\}")
  let result = builder_finalize(b)
  print(result)
}

func bench_loop(N: int) -> float {
  func logic() {
    var c = 0
    for _ in [1..N] { c += 1 }
  }
  return run_avg_ms(3, logic)
}

func bench_dict(N: int) -> float {
  func logic() {
    let d: {string: int} = {}
    for i in [0..N-1] { d.insert("k" + to_text(i), i) }
    var sum = 0
    for j in [0..N-1] { sum += d["k" + to_text(j)] }
  }
  return run_avg_ms(3, logic)
}

func bench_dict_intkey(N: int) -> float {
  func logic() {
    let d: {int: int} = {}
    for i in [0..N-1] { d.insert_int(i, i) }
    var sum = 0
    for j in [0..N-1] { sum += d[j] }
  }
  return run_avg_ms(3, logic)
}

func bench_dict_hot(N: int) -> float {
  // Build dict outside of timing (like Python/Node.js)
  let d: {string: int} = {}
  for i in [0..N-1] { d.insert(to_text(i), i) }
  func logic() {
    for _ in [0..N-1] { let _v = d["0"] }
  }
  return run_avg_ms(3, logic)
}

func bench_string(N: int) -> float {
  func logic() {
    var str = ""
    for i in [0..N-1] { str += to_text(i); str += "," }
  }
  return run_avg_ms(3, logic)
}

func bench_string_builder(N: int) -> float {
  func logic() {
    let b = builder_new()
    for i in [0..N-1] { builder_push(b, i); builder_push(b, ",") }
    let _result = builder_finalize(b)
  }
  return run_avg_ms(3, logic)
}

func bench_struct_method(N: int) -> float {
  func logic() {
    let f = Foo{ x: 1 }
    for i in [0..N-1] { let _v = f.method(i) }
  }
  return run_avg_ms(3, logic)
}

func bench_func_call(N: int) -> float {
  func add1(x: int) -> int { return x + 1 }
  func logic() {
    var sum = 0
    for i in [0..N-1] { sum += add1(i) }
  }
  return run_avg_ms(3, logic)
}

func bench_branch_heavy(N: int) -> float {
  func logic() {
    var sum = 0
    for i in [0..N-1] { if (i % 2) == 0 { sum += 1 } else { sum -= 1 } }
  }
  return run_avg_ms(3, logic)
}

func bench_list_push_pop(N: int) -> float {
  func logic() {
    let l: [int] = []
    for i in [0..N-1] { l.push(i) }
    for _ in [0..N-1] { let _ = l.pop() }
  }
  return run_avg_ms(3, logic)
}

func bench_dict_miss(N: int) -> float {
  // Build dict outside of timing (like Python/Node.js)
  let d: {string: int} = {}
  for i in [0..N-1] { d.insert("k" + to_text(i), i) }
  func logic() {
    var miss = 0
    for j in [0..N-1] { if d.contains("x" + to_text(j)) { miss += 1 } }
  }
  return run_avg_ms(3, logic)
}

func bench_dict_update_hot(N: int) -> float {
  // Create dict outside of timing (like Python/Node.js)
  let d: {string: int} = {}
  d.insert("hot", 0)
  func logic() {
    for i in [0..N-1] { d.insert("hot", i) }
  }
  return run_avg_ms(3, logic)
}

func bench_string_unicode(N: int) -> float {
  func logic() {
    let parts = ["ã“ã‚“ã«ã¡ã¯", "ä¸–ç•ŒðŸŒ", "Xu", "è„šæœ¬"]
    let b = builder_new()
    for i in [0..N-1] { builder_push(b, parts[i % 4]); builder_push(b, ",") }
    let _result = builder_finalize(b)
  }
  return run_avg_ms(3, logic)
}

func bench_string_scan(N: int) -> float {
  // Build string outside of timing (like Python/Node.js)
  var str = ""
  for i in [0..N-1] { str += to_text(i); str += "," }
  func logic() {
    let _c1 = contains(str, "999")
    let _c2 = starts_with(str, "0,1")
    let _c3 = ends_with(str, to_text(N - 1))  // Same as Python/Node: str(n-1) inside timing
  }
  return run_avg_ms(3, logic)  // Run once like Python/Node
}

func main() {
  var N = parse_int(BENCH_SCALE)
  out_json("loop", N, bench_loop(N)); gc()
  out_json("dict", N, bench_dict(N)); gc()
  out_json("dict-intkey", N, bench_dict_intkey(N)); gc()
  out_json("dict-hot", N, bench_dict_hot(N)); gc()
  out_json("string", N, bench_string(N)); gc()
  out_json("string-builder", N, bench_string_builder(N)); gc()
  out_json("struct-method", N, bench_struct_method(N)); gc()
  out_json("func-call", N, bench_func_call(N)); gc()
  out_json("branch-heavy", N, bench_branch_heavy(N)); gc()
  out_json("list-push-pop", N, bench_list_push_pop(N)); gc()
  out_json("dict-miss", N, bench_dict_miss(N)); gc()
  out_json("dict-update-hot", N, bench_dict_update_hot(N)); gc()
  out_json("string-unicode", N, bench_string_unicode(N)); gc()
  out_json("string-scan", N, bench_string_scan(N)); gc()
}

main()
